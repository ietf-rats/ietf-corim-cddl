concise-mid-tag = {
  ? comid.language => language-type
  comid.tag-identity => tag-identity-map
  ? comid.entities => [ + entity-map ]
  ? comid.linked-tags => [ + linked-tag-map ]
  comid.triples => triples-map
  * $$concise-mid-tag-extension
}

language-type = text

tag-identity-map = {
  comid.tag-id => $tag-id-type-choice
  ? comid.tag-version => tag-version-type
}

$tag-id-type-choice /= tstr
$tag-id-type-choice /= uuid-type

tag-version-type = uint .default 0

entity-map = {
  comid.entity-name => $entity-name-type-choice
  ? comid.reg-id => uri
  comid.role => [ + $comid-role-type-choice ]
  * $$entity-map-extension
}

$comid-role-type-choice /= comid.tag-creator
$comid-role-type-choice /= comid.creator
$comid-role-type-choice /= comid.maintainer

linked-tag-map = {
  comid.linked-tag-id => $tag-id-type-choice
  comid.tag-rel => $tag-rel-type-choice
}

$tag-rel-type-choice /= comid.supplements
$tag-rel-type-choice /= comid.replaces

triples-map = non-empty<{
  ? comid.reference-triples => [ + reference-triple-record ]
  ? comid.endorsed-triples => [ + endorsed-triple-record ]
  ? comid.attest-key-triples => [ + attest-key-triple-record ]
  ? comid.identity-triples => [ + identity-triple-record ]
  * $$triples-map-extension
}>

; REFERENCE-VALUE triple
; "target environment $TE" "has reference measurements" "$RV"
reference-triple-record = [
  [ + $env-type-choice ] / environment-map ; target environment
  [ + $tagged-measurement-type-choice ] ; reference measurements
]

; ENDORSED-VALUE triple
; "environment $E" "has endorsed measurements" "$EV"
endorsed-triple-record = [
  [ + $env-type-choice ] / environment-map ; (target or attesting) environment
  [ + $tagged-measurement-type-choice ] ; endorsed measurements
]

; ATTESTATION-VERIFICATION-KEY triple
; "attesting environment $AE" "signs Evidence that can be verified with a set of keys [$K]"
attest-key-triple-record = [
  [ + $env-type-choice ] / environment-map ; attesting environment
  [ + $crypto-key-type-choice ] ; attestation verification key(s)
]

; DEVICE-IDENTITY triple
; "device $D" "is identified by a set of keys [$K]"
identity-triple-record = [
  [ + $env-type-choice ] / environment-map ; device identifier (instance or class)
  [ + $crypto-key-type-choice ] ; DevID, or semantically equivalent
]

$crypto-key-type-choice /= tagged-pkix-base64-key-type
$crypto-key-type-choice /= tagged-pkix-base64-cert-type
$crypto-key-type-choice /= tagged-pkix-base64-cert-path-type

; Raw key in DER format base64-encoded.
tagged-pkix-base64-key-type = #6.554(tstr)
; X.509 certificate in DER format base64-encoded
tagged-pkix-base64-cert-type = #6.555(tstr)
; chain of X.509 certificates in DER format base64-encoded
tagged-pkix-base64-cert-path-type = #6.556(tstr)

;
; Environments
;
; Take care when extending this structure as a verifier will typically not be
; able to match against an environment map containing keys it does not recognise
;
$env-type-choice /= #6.4711(environment-map)
$env-type-choice /= #6.4712(class-map)
$env-type-choice /= #6.4713($instance-id-type-choice)
$env-type-choice /= #6.4714($group-id-type-choice)
$env-type-choice /= #6.4715(source-map)
$env-type-choice /= #6.4716($class-id-type-choice)
$env-type-choice /= #6.4717(vendor-type)
; etc...
;
; note: since environment triple record is [ + env ] there could be multiple values used
; to construct the environment. e.g. [ #6.4715(source-map) #6.4716($class-id-type-choice) ]
; 

source-map {
  ? comid.source => $source-type-choice
  ? comid.authorised-by => $key-type-choice
  * $$environment-map-extension
}
$source-type-choice /= uint
$source-type-choice /= tstr
$source-type-choice /= tagged-uuid-type

environment-map = non-empty<{
  ? comid.class => class-map
  ? comid.instance => $instance-id-type-choice
  ? comid.group => $group-id-type-choice
}>

class-map = non-empty<{
  ? comid.class-id => $class-id-type-choice
  ? comid.vendor => vendor-type
  ? comid.model => tstr
  ? comid.layer => uint
  ? comid.index => uint
}>
vendor-type = tstr

$class-id-type-choice /= tagged-oid-type
$class-id-type-choice /= tagged-uuid-type
$class-id-type-choice /= tagged-int-type

$instance-id-type-choice /= tagged-ueid-type
$instance-id-type-choice /= tagged-uuid-type

$group-id-type-choice /= tagged-uuid-type

;
; From draft-ietf-cbor-tags-oid (TODO(tho), roid and pen)
;
oid-type = bytes
tagged-oid-type = #6.111(oid-type)

;
; github.com/lucas-clemente/cbor-specs/blob/master/uuid.md
;
tagged-uuid-type = #6.37(uuid-type)

;
; numeric class identifer.  MUST be coupled with vendor.
;
tagged-int-type = #6.551(int)

;
; From draft-ietf-rats-eat
;
ueid-type = bytes .size 33
tagged-ueid-type = #6.550(ueid-type)

$measured-element-type-choice /= tagged-oid-type
$measured-element-type-choice /= tagged-uuid-type
$measured-element-type-choice /= uint

measurement-map = {
  ? comid.mkey => $measured-element-type-choice
  comid.mval => $tagged-measurement-type-choice / measurement-values-map
}

;
; Measurements as type-choice
;
$tagged-measurement-type-choice /= bstr .cbor #6.1170(measurement-map)
$tagged-measurement-type-choice /= bstr .cbor #6.1171(measurement-values-map)
$tagged-measurement-type-choice /= bstr .cbor #6.1172(version-map)
$tagged-measurement-type-choice /= bstr .cbor tagged-svn
$tagged-measurement-type-choice /= bstr .cbor tagged-min-svn
$tagged-measurement-type-choice /= bstr .cbor #6.1173(digests-type)
$tagged-measurement-type-choice /= bstr .cbor #6.1174(tstr-set-type)
$tagged-measurement-type-choice /= bstr .cbor #6.1175([tagged-date, operators-map])
$tagged-measurement-type-choice /= bstr .cbor #6.1176([tagged-set-bstr, operators-map])
$tagged-measurement-type-choice /= bstr .cbor #6.1177([tagged-set-tstr, operators-map])
$tagged-measurement-type-choice /= bstr .cbor #6.1178([tagged-set-float16, operators-map])
$tagged-measurement-type-choice /= bstr .cbor #6.1179([tagged-set-float32, operators-map])
$tagged-measurement-type-choice /= bstr .cbor #6.1180([tagged-set-float64, operators-map])
$tagged-measurement-type-choice /= bstr .cbor #6.1181([tagged-set-int, operators-map])
$tagged-measurement-type-choice /= bstr .cbor #6.1182([tagged-set-uint, operators-map])
; operators as n-fix logic as <operator, operand, ...> tuple
$tagged-measurement-type-choice /= bstr .cbor #6.1183([op-gt tagged-set-uint tagged-set-uint])
; could do recursion with endorsed-triple-records as measurements to link a matched reference claim to endorsed claims
$tagged-measurement-type-choice /= bstr .cbor #6.1184(endorsed-triple-record)
; etc...

;
; Measurements as map structure
; see https://github.com/ietf-rats/ietf-corim-cddl/issues/72
;
measurement-values-map = non-empty<{
  ? comid.ver => version-map
  ? comid.svn => svn-type-choice
  ? comid.digests => digests-type
  ? comid.flags => flags-map
  ? raw-value-group
  ? comid.mac-addr => mac-addr-type-choice
  ? comid.ip-addr =>  ip-addr-type-choice
  ? comid.serial-number => serial-number-type
  ? comid.ueid => ueid-type
  ? comid.uuid => uuid-type
  ? comid.name => tstr
  * $$measurement-values-map-extension
}>
;
; Additional measurement values (potential)
;
$$measurement-values-map-extension //= (
  ? comid.date => [tagged-date, operators-map] ; uses #6.1(int)
  ? comid.tcbstatus => [tagged-tcbstatus, operators-map] ; tbd sgx specific?
  ? comid.set-bstr => [tagged-set-bstr, operators-map]
  ? comid.set-tstr => [tagged-set-tstr, operators-map]
  ? comid.set-float16 => [tagged-set-float16, operators-map]
  ? comid.set-float32 => [tagged-set-float32, operators-map]
  ? comid.set-float64 => [tagged-set-float64, operators-map]
  ? comid.set-int => [tagged-set-int, operators-map]
  ? comid.set-uint => [tagged-set-uint, operators-map]
  )
)


version-map = {
  comid.version => version-type
  ? comid.version-scheme => $version-scheme
  ? comid.ops => operators-map
}
version-type = text .default '0.0.0'
; version-scheme is defined in CoSWID
; supported comparison operators include:
;   .eq - numeric form of major, minor, point values are equal
;   .gt - numeric form of reference major is gt evidence major, 
;       or major is eq and reference minor is gt evidence minor, 
;       or major is eq, minor is eq and reference point is gt evidence point
;   .gte - ref major is gt or eq to evidence major,
;       or major is eq and ref minor is gt or eq to evidence minor,
;       or major is eq, minor is eq ref point is gt or eq to evidence point

svn-type = uint
svn = [svn-type, operators-map]
; supported comparison operators include:
;   .eq - reference uint svn equals evidence svn
min-svn = [svn-type, operators-map]
; supported comparison operators include:
;   .lte - reference uint svn is lt or equal to evidence svn
tagged-svn = #6.552(svn)
tagged-min-svn = #6.553(min-svn)
svn-type-choice = tagged-svn / tagged-min-svn

; flags-map maps DiceTcbInfo.flags
flags-map = {
  ? comid.operational-flag-configured => bool
  ? comid.operational-flag-secure => bool
  ? comid.operational-flag-recovery => bool
  ? comid.operational-flag-debug => bool
  ? comid.operational-flag-replay-protected => bool
  ? comid.operational-flag-integrity-protected => bool
  * $$flags-map-extension
}

raw-value-group = (
  comid.raw-value => $raw-value-type-choice
  ? comid.raw-value-mask => raw-value-mask-type
)

$raw-value-type-choice /= #6.560(bytes)

raw-value-mask-type = bytes

ip-addr-type-choice = ip4-addr-type / ip6-addr-type
ip4-addr-type = bytes .size 4
ip6-addr-type = bytes .size 16

mac-addr-type-choice = eui48-addr-type / eui64-addr-type
eui48-addr-type = bytes .size 6
eui64-addr-type = bytes .size 8

serial-number-type = text

; Notes:
; - hash-entry is defined in CoSWID schema
digests-type = [ + hash-entry ]

; vim: set tw=70 ts=2 et:

; 
; Comparison operators
;
operators-map = {
  ? comid.op-eq => bool
  ? comid.op-gt => bool
  ? comid.op-lt => bool
  ? comid.op-gte => bool
  ? comid.op-lte => bool
  ? comid.op-set => bool
  ? comid.op-subset => bool
  ? comid.op-superset => bool
  ? comid.op-disjointset => bool
  ? comid.op-member => bool
  ? comid.op-non-member => bool
  * $$operators-map-extension
}
;
; Operators as type-choice
;
$operator-type-choice /= op-eq
op-eq = 1
$operator-type-choice /= op-gt
op-gt = 2
; etc...
