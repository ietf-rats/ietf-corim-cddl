concise-mid-tag = {
  ; TODO(tho) language
  ; TODO(tho) tag-id
  ; TODO(tho) module-name
  ; TODO(tho) entity
  ; TODO(tho) linked-tags
  comid.triples => triples-map
  ; TODO(tho) extension
}

triples-map = non-empty<{
  ? comid.reference-triples => one-or-more<reference-triple-record>
  ? comid.endorsed-triples => one-or-more<endorsed-triple-record>
  ? comid.attest-key-triples => one-or-more<attest-key-triple-record>
  ? comid.identity-triples => one-or-more<identity-triple-record>
  * $$triples-map-extension
}>

; REFERENCE-VALUE triple
; "target environment $TE" "has reference measurements" "$RV"
; NOTE(tho): can an attesting evironement have reference values?
reference-triple-record = [
  environment-map ; target environment
  one-or-more<measurement-map> ; reference measurements
]

; ENDORSED-VALUE triple
; "environment $E" "has endorsed measurements" "$EV"
endorsed-triple-record = [
  environment-map ; (target or attesting) environment
  one-or-more<measurement-map> ; endorsed measurements
]

; ATTESTATION-VERIFICATION-KEY triple
; "attesting environment $AE" "signs Evidence that can be verified with key" "$K"
attest-key-triple-record = [
  environment-map ; attesting environment
  one-or-more<verification-key> ; attestation verification key(s)
]

; DEVICE-IDENTITY triple
; "device $D" "is identified by key" "$K"
identity-triple-record = [
  environment-map ; device identifier (instance or class)
  one-or-more<verification-key> ; DevID, or semantically equivalent
]

verification-key = {
  ; Verification key (typically a public key)
  corim.key => COSE_Key
  ; Optional X.509 certificate chain corresponding to the public key
  ; in corim.key, encoded as an array of one or more base64-encoded
  ; DER PKIX certificates.  The certificate containing the public key
  ; in corim.key MUST be the first certificate.  This MAY be followed
  ; by additional ; certificates, with each subsequent certificate
  ; being the one used to certify the previous one.
  ? corim.keychain => [ + tstr ]
}

environment-map = non-empty<{
  ? comid.class => class-map
  ? comid.instance => $instance-id-type-choice
}>

class-map = {
  comid.class-id => $class-id-type-choice
  ? comid.vendor => tstr
  ? comid.model => tstr
  ? comid.layer => uint
  ? comid.index => uint
}

; generic name-spaced identifier
ns-auth = tstr
ns-id<id> = [ ns-auth, id ]

tagged-uuid-class-type = #6.900(ns-id<uuid-type>)
tagged-model-class-type = #6.901(ns-id<tstr>)

$class-id-type-choice /= tagged-oid-type
$class-id-type-choice /= tagged-impl-id-type
$class-id-type-choice /= tagged-uuid-class-type
$class-id-type-choice /= tagged-model-class-type

$instance-id-type-choice /= tagged-ueid-type
$instance-id-type-choice /= tagged-uuid-type

;
; From draft-ietf-cbor-tags-oid (TODO(tho), roid and pen)
;
oid-type = bytes
tagged-oid-type = #6.111(oid-type)

;
; github.com/lucas-clemente/cbor-specs/blob/master/uuid.md
;
tagged-uuid-type = #6.37(uuid-type)

;
; From draft-ietf-rats-eat
;
ueid-type = bytes .size 33
tagged-ueid-type = #6.48000(ueid-type)

;
; From draft-tschofenig-rats-psa-token
;
impl-id-type = bytes .size 32
tagged-impl-id-type = #6.47115(impl-id-type)

; see https://github.com/ietf-rats/ietf-corim-cddl/issues/72
measurement-map = non-empty<{
  ? comid.ver => version-map
  ? comid.svn => svn-type
  ? comid.digests => digests-type
  ? comid.flags => flags-type
  ? raw-value-group
  ? comid.mac-addr => mac-addr-type-choice
  ? comid.ip-addr => ip-addr-type-choice
  ? comid.serial-number => serial-number-type
  ? comid.ueid => ueid-type
  ? comid.uuid => uuid-type
  * $$measurement-map-extension
}>

version-map = {
  comid.version => version-type
  ? comid.version-scheme => $version-scheme
}
version-type = text .default '0.0.0'
; version-scheme is defined in CoSWID

svn-type = int
flags-type = bytes .bits operational-flags

; operational-flags maps DiceTcbInfo.flags, i.e.:
; OperationalFlags ::= BIT STRING {
;   notConfigured (0),
;   notSecure (1),
;   recovery (2),
;   debug (3)
; }
operational-flags = &(
  not-configured: 0
  not-secure: 1
  recovery: 2
  debug: 3
)

raw-value-group = (
  comid.raw-value => raw-value-type
  ? comid.raw-value-mask => raw-value-mask-type
)

raw-value-type = bytes
raw-value-mask-type = bytes

ip-addr-type-choice = ip4-addr-type / ip6-addr-type
ip4-addr-type = bytes .size 4
ip6-addr-type = bytes .size 16

mac-addr-type-choice = eui48-addr-type / eui64-addr-type
eui48-addr-type = bytes .size 6
eui64-addr-type = bytes .size 8

serial-number-type = text

; Notes:
; - hash-entry is defined in CoSWID schema
digests-type = one-or-more<hash-entry>

; vim: set tw=70 ts=2 et:
